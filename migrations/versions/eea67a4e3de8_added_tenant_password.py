"""added tenant password

Revision ID: eea67a4e3de8
Revises: 546e001ed4c9
Create Date: 2025-06-22 16:26:39.124388

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.sql import text


# revision identifiers, used by Alembic.
revision = 'eea67a4e3de8'
down_revision = '546e001ed4c9'
branch_labels = None
depends_on = None


def upgrade():
    conn = op.get_bind()
    
    # Check if column exists first
    inspector = sa.inspect(conn)
    columns = inspector.get_columns('tenants')
    column_names = [c['name'] for c in columns]
    
    if 'password' not in column_names:
        with op.batch_alter_table('tenants', schema=None) as batch_op:
            batch_op.add_column(sa.Column('password', sa.String(length=255), 
                               nullable=False, server_default='temp_password')
            )
    # Rest of your migration code...
    # ### commands auto generated by Alembic - please adjust! ###
    
    # First add the password column with a temporary default
    with op.batch_alter_table('tenants', schema=None) as batch_op:
        batch_op.add_column(sa.Column('password', sa.String(length=255), nullable=False, server_default='temp_password'))
    
    # For SQLite, we need to close the current transaction before proceeding
    # We'll do this by ending the batch operation context
    
    # Now set the actual passwords in a separate operation
    conn = op.get_bind()
    tenants = conn.execute(text("SELECT id, first_name FROM tenants")).fetchall()
    
    for tenant in tenants:
        default_password = f"{tenant[1].lower().replace(' ', '')}@123"
        conn.execute(
            text("UPDATE tenants SET password = :password WHERE id = :id"),
            {"password": default_password, "id": tenant[0]}
        )
    
    # Finally add the unique constraint on email
    with op.batch_alter_table('tenants', schema=None) as batch_op:
        # First check for duplicate emails
        duplicates = conn.execute(text("""
            SELECT email, COUNT(*) as count 
            FROM tenants 
            GROUP BY email 
            HAVING count > 1
        """)).fetchall()
        
        # Fix duplicates by appending id
        for email, count in duplicates:
            conn.execute(
                text("""
                    UPDATE tenants 
                    SET email = id || '_' || email 
                    WHERE email = :email AND id NOT IN (
                        SELECT MIN(id) FROM tenants WHERE email = :email
                    )
                """),
                {"email": email}
            )
        
        # Now add the named unique constraint
        batch_op.create_unique_constraint('uq_tenants_email', ['email'])
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('tenants', schema=None) as batch_op:
        batch_op.drop_constraint('uq_tenants_email', type_='unique')
        batch_op.drop_column('password')
    # ### end Alembic commands ###